### 执行上下文栈

#### 什么是执行上下文？

简而言之，执行上下文就是当前JavaScript代码被解析和执行时所在环境的抽象概念，JavaScript中运行任何的代码都是在执行上下文中运行。

#### 执行上下文的类型

执行上下文总共分三种类型

- 全局执行上下文： 这是默认的，最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。他做了两件事： 1. 创建一个全局对象，在浏览器中这个全局对象就是window对象。 2.讲this指针（内存地址）指向这个全局对象。一个程序只能存在一个全局执行上下文。
- 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但只有函数被调用的时候才会被创建。一个程序可以存在任意数量的函数上下文。每当一个新的执行上下文被创建，他都会按照特定的顺序执行一系列步骤，具体过程后文讨论。

#### 执行上下文的生命周期

执行上下文的生命周期包括三个阶段： 创建阶段 > 执行阶段 > 回收阶段

1. 创建阶段

   当函数被调用，但未执行任何其内部代码之前，会做以下三件事：

   - 创建变量对象： 首先初始化函数的参数arguments， 提升函数声明和变量声明。
   - 创建作用域链（scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
   - 确定this指向： 包括多种情况，下文会详细说明。

在一段JS脚本执行之前，要先解析代码（所以说JS是解析执行的脚本语言），解析的时候会创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后开始正式执行程序。



#### 执行顺序？

如果要问到JavaScript代码执行顺序的话，想必写过JavaScript都会有个直观的印象，那就是顺序执行，毕竟：

```js
function foo() {

    console.log('foo1');

}

foo();  // foo2

function foo() {

    console.log('foo2');

}

foo(); // foo2
```

打印的结果却是两个`foo2`

刷过面试题的都知道这是因为JavaScript引擎并非一行一行地分析和执行程序，而是一段一段的分析执行。当执行一段代码的时候，会进行一个`准备工作`，比如第一个例子中的变量提升，和第二个例子中的函数提升。

但本文真正想让大家思考的是： 这个一段一段中的段究竟是怎么划分的呢？

到底JavaScript引擎遇到一段怎样的代码才会做`准备工作`呢？

#### 可执行代码

这就要说道JavaScript可执行代码（executable code）的类型有哪些了？

其实很简单，就三种，全局代码，函数代码，`eval`代码。

举个例子，当执行一个函数的时候，就会进行准备工作，这里的`准备工作`，让我们用这个更专业一点的说话，就是`执行上下文（execution contexts）`

#### 执行上下文栈

接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？

所以JavaScript引擎创建了一个执行上下文栈（Execution context stack，ECS）来管理执行上下文为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组

```js
    ECStack = [];
```

试想当JavaScript开始要解释执行代码的时候，最先遇到的是就是全局代码。所以初始化的时候首先会向执行上下文栈压入一个全局执行上下文，我们用`globalContext`表示它，并且只有当整个应用程序结束的时候，`ECStack`才会被清空，所以`ECStack`最底部永远有个`globalContext`

```js
ECStack = [
        globalContext
 ];
```

现在JavaScript遇到下面的这段代码了：

```js
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();
```

当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码。

```js
// 伪代码

// fun1()
ECStack.push(<fun1> functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2> functionContext);

// 擦，fun2还调用了fun3！
ECStack.push(<fun3> functionContext);

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

